# Obtaining Data {#chapter-3-obtaining-data}

```{console reset}
cd /data/ch03
rm -rf logs
rm top2000.xlsx
rm top2000.csv

```

This chapter deals with the first step of the OSEMN model: obtaining data. After all, without any data, there is not much data science that we can do. I assume that the data that is needed to solve the data science problem at hand already exists at some location in some form. Our goal is to get this data onto your computer (or into your Data Science Toolbox) in a form that we can work with.

According to the Unix philosophy, text is a universal interface. Almost every command-line tool takes text as input, produces text as output, or both. This is the main reason why command-line tools can work so well together. However, as we'll see, even just text can come in multiple forms.

Data can be obtained in several ways---for example by downloading it from a server, by querying a database, or by connecting to a Web API. Sometimes, the data comes in a compressed form or in a binary format such as Microsoft Excel. In this chapter, I discuss several tools that help tackle this from the command line, including: `curl` [@curl], `in2csv` [@in2csv], `sql2csv` [@sql2csv], and `tar` [@tar].

## Overview

In this chapter, you’ll learn how to:

- Obtain data from the Internet
- Query databases
- Connect to Web APIs
- Decompress files
- Convert Microsoft Excel spreadsheets into usable data

```{console cd}
cd /data/ch03
l
```

## Copying Local Files to the Data Science Toolbox

A common situation is that you already have the necessary files on your own computer. This section explains how you can get those files into the Data Science Toolbox.

I mentioned in [Chapter 2](#chapter-2-getting-started) that the Data Science Toolbox is an isolated virtual environment. Luckily there is one exception to that: files can be transfered in and out the Data Science Toolbox. The local directory from which you ran `docker run`, is mapped to a directory in the Data Science Toolbox. This directory is called */data*. Please note that this is not your home directory.

If you have a file on your local computer, and you want to apply some command-line tools to it, all you have to do is copy or move the file to that directory. Let’s assume that you have a file called *logs.csv* on your desktop. If you are running Linux or macOS, execute the following command on your operating system (and not inside the Data Science Toolbox):

```{bash, eval=FALSE}
$ cp ~/Desktop/logs.csv .
```

And if you are running Windows, you can run the following commands on the command prompt:

```powershell
> cd %UserProfile%\Desktop
> copy logs.csv MyDataScienceToolbox\
```

Of course you can also drag-and-drop the file into the right directory using a graphical file manager such as macOS Finder and Windows Explorer.

## Decompressing Files

If the original data set is very large or it's a collection of many files, the file may be a (compressed) archive. Data sets which contain many repeated values (such as the words in a text file or the keys in a JSON file) are especially well suited for compression.

Common file extensions of compressed archives are: *.tar.gz*, *.zip*, and *.rar*. To decompress these, you would use the command-line tools `tar` [@tar], `unzip` [@unzip], and `unrar` [@unrar], respectively. There exists a few more, though less common, file extensions for which you would need yet other tools. For example, in order to extract a file named *logs.tar.gz*, you would use:

```{console tar, eval=FALSE}
pwd
tar -tzf logs.tar.gz | wc -l
tar -tzf logs.tar.gz | trim
mkdir logs
tar -xzf logs.tar.gz -C logs
cd logs
ls | wc -l
cat $(ls | head) | trim
cd ..
pwd
```

Indeed, `tar` is notorious for its many command-line arguments. In this case, the four command-line arguments `x`, `z`, `v`, and `f` specify that `tar` should *extract* files from an archive, use *gzip* as the decompression algorithm, be *verbose* and use file *logs.tar.gz*. In time, you'll get used to typing these four characters, but there's a more convenient way.

Rather than remembering the different command-line tools and their options, there's a handy script called `unpack` [@unpack], which will decompress many different formats. `unpack` looks at the extension of the file that you want to decompress, and calls the appropriate command-line tool.

The `unpack` tool is part of the Data Science Toolbox. Remember that you can look up how it can be installed in the appendix. Below is the source of `unpack`. Although Bash scripting is not the focus of this book, it’s still useful to take a moment to figure out how it works.

```{console}
bat $(which unpack)
```

Now, in order to decompress this same file, you would simply use:

```{bash, eval=FALSE}
$ unpack logs.tar.gz
```

## Converting Microsoft Excel Spreadsheets to CSV

For many people, Microsoft Excel offers an intuitive way to work with small data sets and perform calculations on them. As a result, a lot of data is embedded into Microsoft Excel spreadsheets. These spreadsheets are, depending on the extension of the filename, stored in either a proprietary binary format (*.xls*) or as a collection of compressed XML files (*.xlsx*). In both cases, the data is not readily usable by most command-line tools. It would be a shame if we could not use those valuable data sets just because they are stored this way.

Luckily, there is a command-line tool called `in2csv` [@in2csv], which is able to convert Microsoft Excel spreadsheets to CSV files. CSV stands for comma-separated values. Working with CSV can be tricky because it lacks a formal specification. [RFC 4180](http://www.ietf.org/rfc/rfc4180.txt) defines the CSV format according to the following three points:

1.  Each record is located on a separate line, delimited by a line break (`␊`). For example:

```{console}
bat -A tmnt-basic.csv
```

2.  The last record in the file may or may not have an ending line break. For example:

```{console}
bat -A tmnt-missing-newline.csv
```

3.  There may be a header appearing as the first line of the file with the same format as normal record lines. This header will contain names corresponding to the fields in the file and should contain the same number of fields as the records in the rest of the file. For example:

```{console}
bat -A tmnt-with-header.csv
```

`csvlook` is nice.

```{console}
csvlook tmnt-with-header.csv
csvlook tmnt-basic.csv
csvlook -H tmnt-missing-newline.csv
```



Let’s demonstrate `in2csv` using a spreadsheet that contains the top 250 movies from the Internet Movie Database (IMDb). The file is named *imdb-250.xlsx* and can be obtained from <http://www.overthinkingit.com/2011/10/11/imdb-top-250-movies-4th-edition/2>. To extract its data, you invoke `in2csv` as follows:

```{console in2csv_save}
curl https://www.nporadio2.nl/data/download/TOP-2000-2020.xlsx > top2000.xlsx
in2csv top2000.xlsx | tee top2000.csv | trim
```

The format of the file is automatically determined by the extension, *.xlsx* in this case. If you were to pipe the data into `in2csv`, you would have to specify the format explicitly.

As you can see, CSV by default is not too readable. You can pipe the data to a tool called `csvlook` [@csvlook], which will nicely format the data into a table. Here, I display a subset of the columns using `csvcut` such that the table fits on the page:

```{console in2csv_csvlook}
csvlook --no-inference --max-column-width 20 top2000.csv
```

A spreadsheet can contain multiple worksheets. By default, `in2csv` extracts the first worksheet. To extract a different worksheet, you need to pass the name of worksheet to the `--sheet` option.

The tools `in2csv`, `csvcut`, and `csvlook` are actually part of Csvkit, which is collection of command-line tools to work with CSV data. Csvkit will be used quite often in this book because it has so many valuable tools. If you’re running the Data Science Toolbox, you already have Csvkit installed. Otherwise, see the appendix for instructions on how to install it.

```{block2, type="rmdnote"}
An alternative approach to `in2csv` is to open the spreadsheet in Microsoft Excel or an open source variant such as LibreOffice Calc, and manually export it to CSV. While this works as a one-off solution, the disadvantage is that it does not scale well to multiple files and is not automatable. Furthermore, when you are working on the command line of a remote server, chances are that you don't have such an application available.
```


## Querying Relational Databases

Most companies store their data in a relational database. Examples of relational databases are MySQL, PostgreSQL, and SQLite. These databases all have a slightly different way of interfacing with them. Some provide a command-line tool or a command-line interface, while others do not. Moreover, they are not very consistent when it comes to their usage and output.

Fortunately, there is a command-line tool called `sql2csv`, which is part of the Csvkit suite. Because it leverages the Python SQLAlchemy package, we only have to use one tool to execute queries on many different databases through a common interface, including MySQL, Oracle, PostgreSQL, SQLite, Microsoft SQL Server, and Sybase. The output of `sql2csv` is, as its name suggests, in CSV format.

We can obtain data from relational databases by executing a `SELECT` query on them. (`sql2csv` also support `INSERT`, `UPDATE`, and `DELETE` queries, but that's not the purpose of this chapter.) To select a specific set of data from a relational database, `sql2csv` needs two arguments: `--db`, which specifies the database URL, of which the typical form is: `dialect+driver://username:password@host:port/database` and `--query`, which contains the `SELECT` query. For example, given a database related to music called *chinook.db*, I can list a few albums by Metallica as follows:

```{console}
sql2csv --db 'sqlite:///chinook.db' --query 'SELECT Artists.Name AS artist,'\
'Albums.Title AS album FROM Artists LEFT JOIN Albums ON Artists.ArtistId = '\
'Albums.ArtistId WHERE Artists.Name = "Metallica" ORDER BY album' | csvlook
```


## Downloading from the Internet

The Internet provides, without a doubt, the largest resource for data. This data is available in various forms, using various protocols. The command-line tool cURL [@curl] can be considered the command line's Swiss Army knife when it comes to downloading data from the Internet.

When you access a URL, which stands for *uniform resource locator*, through your browser, the data that's being downloaded can be interpreted. For example, an HTML file is nicely rendered as a website, an MP4 file may be automatically played, and a PDF file may be automatically displayed. However, when cURL is used to access a URL, the data is downloaded and printed to standard output. Other command-line tools may then be used to process this data further.

The easiest invocation of cURL is to simply specify a URL as a command-line argument. For example, to download the book *Adventures of Huckleberry Finn* by Mark Twain from Project Gutenberg, you can run the following command:

```{console curl_finn}
curl -s http://www.gutenberg.org/files/76/76-0.txt | trim
```

By default, cURL outputs a progress meter that shows how the download rate and the expected time of completion. If you are piping the output directly to another command-line tool, such as `head`, be sure to specify the `-s` command-line argument, which stands for *silent*, so that the progress meter is disabled. Compare, for example, the output with the following command:

```{console no_silent}
curl http://www.gutenberg.org/files/76/76-0.txt | trim
```

Note that the output of the second command, where we do not disable the progress meter, contains the unwanted text and even an error message. If you save the data to a file, then you do not need to necessarily specify the `-s` option:

```{console curl_redirect}
curl http://www.gutenberg.org/files/76/76-0.txt > finn.txt
```

You can also save the data by explicitly specifying the output file with the `-o` option:

```{console curl_o}
curl -s http://www.gutenberg.org/files/76/76-0.txt -o data/finn.txt
```

When downloading data from the Internet, the URL will most likely use the protocols HTTP or HTTPS. To download from an FTP server, which stands for File Transfer Protocol, you use cURL in exactly the same way. When the URL is password protected, you can specify a username and a password as follows:

```{bash, eval=FALSE}
$ curl -u username:password ftp://host/file
```

If the specified URL is a directory, `curl` will list the contents of that directory.

When you access a shortened URL, such as the ones that start with *http://bit.ly/* or *http://t.co/*, your browser automatically redirects you to the correct location. With `curl`, however, you need to specify the `-L` or `--location` option in order to be redirected:

```{console curl_follow}
curl -L j.mp/locatbbar
```

If you do not specify the `-L` or `--location` option, you may get something like:

```{console curl_nofollow}
curl j.mp/locatbbar
```

By specifying the `-I` or `--head` option, `curl` fetches only the HTTP header of the response:

```{console curl_head}
curl -I j.mp/locatbbar | trim
```

The first line indicates the HTTP status code, which is 301 (moved permanently) in this case. You can also see the location this URL redirects to: <http://en.wikipedia.org/wiki/List_of_countries_and_territories_by_border/area_ratio>. Inspecting the header and getting the status code is a useful debugging tool in case `curl` does not give you the expected result. Other common HTTP status codes include 404 (not found) and 403 (forbidden). This page lists all HTTP status codes: <http://en.wikipedia.org/wiki/List_of_HTTP_status_codes>.

In summary, cURL is a straight-forward command-line tool for downloading data from the Internet. Its three most common command-line arguments are `-s` to suppress the progress meter, `-u` to specify a username and password, and `-L` to automatically follow redirects. See its man page for more information.


## Calling a Web API

In the previous section I explained how to download individual files from the Internet. Another way data can come from the Internet is through a web API, which stands for *Application Programming Interface*. The number of APIs that are being offered by organizations is growing at increasing rate, which means a lot of interesting data for us data scientists.

Web APIs are not meant to be presented in nice layout, such as websites. Instead, most web APIs return data in a structured format, such as JSON or XML. Having data in a structured form has the advantage that the data can be easily processed by other tools, such as `jq`. For example, the API from <https://randomuser.me> returns data in the following JSON structure.

```{console curl_api}
curl -s https://anapioficeandfire.com/api/characters/583 | jq . | trim
```

The data is piped to a command-line tool `jq` in order to display it in a nice way. `jq` has many more possibilities that I will explore in [Chapter 5](#chapter-5-scrubbing-data).

Some web APIs return data in a streaming manner. This means that once you connect to it, the data will continue to pour in forever. A well-known example is the Twitter "firehose", which constantly streams all the tweets being sent around the world. Luckily, most command-line tools that we use also operate in a streaming matter, so that we also use this kind of data.

Some APIs require you to log in using the OAuth protocol. There is a handy command-line tool called `curlicue` [@curlicue] that assists in performing the so-called "OAuth dance". Once this has been set up, it `curlicue` will call `curl` with the correct headers. First, you set things up once for a particular API with `curlicue-setup`, and then you can call that API using `curlicue`. For example, to use `curlicue` with the Twitter API you would run:

```{bash, eval=FALSE}
$ curlicue-setup \
> 'https://api.twitter.com/oauth/request_token' \
> 'https://api.twitter.com/oauth/authorize?oauth_token=$oauth_token' \
> 'https://api.twitter.com/oauth/access_token' \
> credentials
$ curlicue -f credentials \
> 'https://api.twitter.com/1/statuses/home_timeline.xml'
```

For more popular APIs, there are specialized command-line tools available. These are wrappers that provide a convenient way to connect to the API.

## Further Reading

* Molinaro, Anthony. 2005. <em>SQL Cookbook</em>. O’Reilly Media.
* Wikipedia. 2014. “List of Http Status Codes.” <a href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes" class="uri">http://en.wikipedia.org/wiki/List_of_HTTP_status_codes</a>.
